## 인터페이스
> 클래스들이 구현해야 하는 메소드들을 추상화 시켜놓은 것

## 인터페이스 내부메서드
> 인터페이스에 선언된 모든 메서드들은 자동으로 public처리가 된다. 그러나, 의도를 더 명확하게 드러내기 위해서 public선언하는 경우도 있다. 인터페이스내에 변수는 초기화를 해줘야 한다.(내부 변수는 public static final이기 때문에) => 변경불가능

`인터페이스를 구현한 클래스안에 메서드 정의시 무조건 public으로 해야되는 이유??? 다른 패키지에서도 접근가능하게??`

`클래스가 인터페이스의 메서드 중 일부만 구현한다면 해당 클래스는 반드시 추상클래스로 선언해야 한다.`

## 인터페이스 타입
> 변수를 인터페이스 타입으로 선언할 수 있지만, 타입이 인터페이스 자체인 객체는 생성할 수 없다. 모든 객체는 클래스의 인스턴스여야 한다.

## 서브타입/슈퍼타입
> 서브타입의 모든 값을 변환 없이 슈퍼타입 변수에 할당 할 수 있으면 서브타입,슈퍼타입 관계가 성립된다.

## 슈퍼타입 -> 서브타입
> 서브타입형으로 슈퍼타입을 선언하려면 타입변환을 해줘야 한다. 타입변환을 하면 서브타입의 메서드를 사용할 수 있다. 객체는 해당 클래스의 슈퍼타입으로만 타입을 변환할 수 있다.

## instanceof
> 객체 instanceof 타입 객체가 타입을 슈퍼타입으로 두고 있는 클래스의 인스턴스일 경우 true를 반환한다.

## 인터페이스 확장
> 인터페이스 간에 extends키워드를 통해 확장이 가능하다. 확장된 인터페이스를 구현하는 클래스는 두 인터페이스내 메서드를 모두 구현해야 한다. 해당 클래스의 객체는 두 인터페이스 타입 중 어느것으로도 타입변환을 할 수 있다.
인터페이스는 몇개든지 구현할 수 있다. 구현한 클래스는 선언된 인터페이스 모두를 슈퍼타입으로 둔다.

## 정적메서드/기본메서드
> JAVA8이전에는 인터페이스의 모든 메서드가 추상메서드여야 했지만 이후로는 구현부가 있는 메서드를 추가할 수 있다. 대신 정적(static)메서드이거나 기본메서드일 경우는 default제어가가 붙어야 한다. 정적메서드나 기본메서드가 있는 인터페이스를 구현한 클래스는 메서드를 Override하거나 기본구현을 상속하는 방법을 선택해서 사용할 수 있다.

`정적메소드 호출시 인터페이스명.함수명 으로만 호출가능???`

## 메서드충돌 해결
> 여러개의 인터페이스 내에 메서드명이 같은 메서드가 존재하고 그 인터페이스들을 구현한 클래스에서 메서드를 구현할때 인터페이스명.super.메서드명 으로 메서드충돌을 해결한다. 구현한 인터페이스중 메서드명이 같은 메서드중 한개라도 구현부가 있으면 메서드충돌이 일어난다.
```
interface A{ default int a() { return 0;} }
interface B{ default int a() { return 1;} }

public class C implements A, B { public int a() { return A.super.a();} }
```
## 람다 표현식 / 메서드 참조
```
ex) Arrays.sort(strings, (x, y) -> x.compareToIgnoreCase(y));

= Arrays.sort(strings, String::compareToIgnoreCase);
```
## 람다 표현식 사용 목적
> 지연 실행을 위해 사용된다.

## 별도의 스레드에서 코드 실행
```
1.코드를 여러 번 실행
2.알고리즘의 올바른 지점에서 코드 실행
3.어떤 일(버튼 클릭,데이터 수신 등)이 일어날 때 코드 실행
4.필요할 때만 코드 실행
5.함수형 인터페이스 구현
@FunctionalInterface 애너테이션을 붙여준다. -> 알아서 추상 메서드 하나만 있는 인터페이스인지 시스템에서 검사한다.
```

`람다표현식 유효범위 <-> 향상된 for 루프 유효범위`

## 지역 클래스
> 메서드 안에 정의한 클래스를 뜻한다. 한번 사용하고 더이상 사용하지 않을 클래스를 메서드 안에서 정의하여 사용한다. 단, 메서드 바깥에서 이 클래스에 접근할 수 없으므로 public이나 private으로 선언할 수 없다.





슈퍼타입->서브타입으로 할때 그냥 처음부터 서브타입으로 선언하면 되는걸 왜 슈퍼타입으로
선언한후에 서브타입으로 캐스팅해서 쓰는지? 어떤경우에 ????

=> 현실적으로 인터페이스 내부에 있는 메소드만 접근하지 그 밑에 구현된 메소드를 불러오는 경우는 없다.
인터페이스 -> 추상화시킨다.
