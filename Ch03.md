## 인터페이스
> 클래스들이 구현해야 하는 메소드들을 추상화 시켜놓은 것

## 인터페이스 내부메서드
> 인터페이스에 선언된 모든 메서드들은 자동으로 public처리가 된다. 그러나, 의도를 더 명확하게 드러내기 위해서 public선언하는 경우도 있다. 인터페이스내에 변수는 초기화를 해줘야 한다.(내부 변수는 public static final이기 때문에) => 변경불가능
`인터페이스를 구현한 클래스안에 메서드 정의시 무조건 public으로 해야되는 이유??? 다른 패키지에서도 접근가능하게??`

## 인터페이스에 인스턴스 변수 사용 불가 이유
> 인터페이스는 객체의 상태가 아니라 동작을 명시한다.

`클래스가 인터페이스의 메서드 중 일부만 구현한다면 해당 클래스는 반드시 추상클래스로 선언해야 한다.`

## 인터페이스 타입
> 변수를 인터페이스 타입으로 선언할 수 있지만, 타입이 인터페이스 자체인 객체는 생성할 수 없다. 모든 객체는 클래스의 인스턴스여야 한다.
```
p.208
슈퍼타입->서브타입으로 할때 그냥 처음부터 서브타입으로 선언하면 되는걸 왜 슈퍼타입으로
선언한후에 서브타입으로 캐스팅해서 쓰는지? 어떤경우에 ????

=> 현실적으로 인터페이스 내부에 있는 메소드만 접근하지 그 밑에 구현된 메소드를 불러오는 경우는 없다.
인터페이스 -> 추상화시킨다.
```

## 서브타입/슈퍼타입
> 서브타입의 모든 값을 변환 없이 슈퍼타입 변수에 할당 할 수 있으면 서브타입,슈퍼타입 관계가 성립된다.

## 슈퍼타입 -> 서브타입
> 서브타입형으로 슈퍼타입을 선언하려면 타입변환을 해줘야 한다. 타입변환을 하면 서브타입의 메서드를 사용할 수 있다. 객체는 해당 클래스의 슈퍼타입으로만 타입을 변환할 수 있다.

## instanceof
> 객체 instanceof 타입 : 객체가 타입을 슈퍼타입으로 두고 있는 클래스의 인스턴스일 경우 true를 반환한다.

## 인터페이스 확장
> 인터페이스 간에 extends키워드를 통해 확장이 가능하다. 확장된 인터페이스를 구현하는 클래스는 두 인터페이스내 메서드를 모두 구현해야 한다. 해당 클래스의 객체는 두 인터페이스 타입 중 어느것으로도 타입변환을 할 수 있다.

`클래스는 인터페이스를 몇개든지 구현할 수 있다. 구현한 클래스는 선언된 인터페이스 모두를 슈퍼타입으로 둔다.`

## 정적메서드/기본메서드
> JAVA8이전에는 인터페이스의 모든 메서드가 추상메서드여야 했지만 이후로는 구현부가 있는 메서드를 추가할 수 있다. 대신 정적(static)메서드이거나 기본메서드일 경우는 default제어가가 붙어야 한다. 정적메서드나 기본메서드가 있는 인터페이스를 구현한 클래스는 메서드를 Override하거나 기본구현을 상속하는 방법을 선택해서 사용할 수 있다.

## 인터페이스 내에 메소드 구현이 가능하게 한 이유
> 예를 들어, 자바 8에서는 stream메소드가 Collection인터페이스에 추가됐다. 근데 만약 stream메소드가 기본메소드가 아니라 추상메소드라면 Collection인터페이스를 구현한 클래스들은 stream메소드를 구현하지 않았으므로 모두 컴파일에러가 발생하게 된다.

## 메서드충돌 해결
> 여러개의 인터페이스 내에 메서드명이 같은 메서드가 존재하고 그 인터페이스들을 구현한 클래스에서 메서드를 구현할때 인터페이스명.super.메서드명 으로 메서드충돌을 해결한다. 구현한 인터페이스중 메서드명이 같은 메서드중 한개라도 구현부가 있으면 메서드충돌이 일어난다.
```
interface A{ default int a() { return 0;} }
interface B{ default int a() { return 1;} }

public class C implements A, B { public int a() { return A.super.a();} }
```

## Comparable / Comparator 인터페이스 비교
> Comparable 인터페이스의 함수는 비교하고자 하는 객체 내의 비교 함수를 불러와서 비교를 하고, Comparator 인터페이스의 비교 함수는 비교자(Comparator)객체 내에서 직접 호출된다.

## Runnable 인터페이스
> 특정 작업을 별도의 스레드에서 실행하려고 하면 Runnable 인터페이스를 구현해야 한다.
```
Runnable task = new Runnable을 구현한 클래스();
Thread thread = new Thread(task);
thread.start();   -> Overriding한 run() 메소드가 스레드상에서 실행된다.
```

## 람다 표현식 / 메서드 참조
```
ex) Arrays.sort(strings, (x, y) -> x.compareToIgnoreCase(y));

= Arrays.sort(strings, String::compareToIgnoreCase);
```

## 함수형 인터페이스
> 추상 메소드가 한 개만 포함된 인터페이스를 뜻한다. 람다표현식은 함수형 인터페이스에만 사용할 수 있다.

## 람다 표현식이 Object타입에 저장이 안되는 이유
> Object타입은 함수형 인터페이스가 아니라 클래스 떄문이다.

## 람다 표현식 사용 목적
> 지연 실행을 위해 사용된다.

## 별도의 스레드에서 코드 실행
```
1.코드를 여러 번 실행
2.알고리즘의 올바른 지점에서 코드 실행
3.어떤 일(버튼 클릭,데이터 수신 등)이 일어날 때 코드 실행
4.필요할 때만 코드 실행
5.함수형 인터페이스 구현
```

## @FunctionalInterface 애너테이션
> 1추상 메소드가 하나만 있는 함수형 인터페이스인지 검사한다.  
2자바독 페이지에 해당 인터페이스가 함수형 인터페이스라는 문장을 둔다.  

## 지역 클래스
> 메서드 안에 정의한 클래스를 뜻한다. 한번 사용하고 더이상 사용하지 않을 클래스를 메서드 안에서 정의하여 사용한다. 단, 메서드 바깥에서 이 클래스에 접근할 수 없으므로 public이나 private으로 선언할 수 없다.






