## 예외 처리가 필요한 이유
> 메서드를 호출하는 쪽에서 오류를 검사한 후 해당 오류를 처리할 수 없다면, 개발자는 오류 코드를 반환해야 하므로 항상 반환 코드를 검사해야 한다. 또한 검사한 후에 실수로 오류를 전파하지 않으면 더 큰 피해를 입을 수 있다.

## Error / Exception
> Error의 서브클래스는 예외 상황이 일어날 때 던지는 예외이다. ex) 메모리 고갈  
Exception의 서브클래스는 개발자가 보고하는 예외이다.

## 검사 예외 / 비검사 예외
> Exception은 검사 예외(Checked Exception)과 비검사 예외(Unchecked Exception)으로 나뉜다.  
검사 예외는 입력이나 출력 과정에서 파일이 손상되거나 네트워크 연결에 실패하는 상황과 같이 실패가 예상되는 상황에 사용한다.  
비검사 예외는 개발자가 만든 논리 오류를 나타낸다.

`메서드를 오버라이드할 때 슈퍼클래스 메서드에서 선언한 예외보다 광범위한 검사 예외는 던질 수 없다.`

`슈퍼클래스 메서드에 throws절이 없으면 오버라이드하는 메서드에서는 검사 예외를 던질 수 없다.`

## @throws 태그
> 문서화할 만한 내용이 있을 때 throws태그로 문서화한다.
```
@throws NullPointerException filename이 null일 때  
@throws FileNotFoundException filename으로 지정한 파일이 없을 때
```

## try-catch-finally
```
try {
    문장
} catch (예외클래스 ex) {
    핸들러
} finally {
    문장
}
```
> finally절에서 발생한 예외는 try블록에서 발생한 예외를 가릴 수  있기 때문에 예외를 던지면 안된다.

## 단정
> 테스트 중에만 오류를 검사하는 방어적 프로그래밍 방법
```
assert 조건식;
assert 조건식 : 표현식;
```

## 로깅
> 디버깅과정중에 사용되는 API

## 로깅 레벨
> 로깅은 7가지(SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST)가 있다.  
`logger.serLevel(Level.FINE);`  
다음과 같은 코드에 의해 설정된 레벨 이상의 로그만 기록한다.  
기본설정은 상위 세 개 레벨만 기록한다. 그러므로 유용한 디버깅 메시지를 로그로 남기려면 CONFIG이하의 레벨을 사용해야 한다.

`throws를 이용해서 사용자에게 오류를 던져줄수가 있는데 처리를 해서 보내면 되는걸 왜 오류를 던지는지?? 오류를 발견한 상황인데??`