## 제네릭 타입 파라미터가 기본 타입이 안되는 이유
> JDK1.5이전에는 제네릭이란 개념이 없었기때문에 이전 코드와의 호환성을 위해 제네릭은 컴파일 과정에서 타입 파라미터는 모두 Object로 변환되어 실행된다.  
즉, 제네릭이란 개념은 존재하지 않는다. 코드작성상에서만 존재하는 개념일뿐 컴파일 과정에서는 존재하지 않는 개념이다.  
기본 타입의 경우는 Object의 서브클래스가 아니므로 사용할 수 없다.

## 타입 경계
> 타입 경계를 통해 특정 타입 파라미터만 받게 할 수 있다.  
extends를 사용하여 특정 타입만 받을 수 있고, 특정 인터페이스를 구현한 클래스만 받고 싶을 경우에도   
`T extends 인터페이스명`으로 받을수 있다.  
다중으로 경계도 지정이 가능하다. 단, 클래스 경계는 하나만 지정할 수 있고, 인터페이스 경계는 제한이 없다.

## 배열은 타입 경계가 필요하지 않은 이유(공변성)
> 배열은 서브타입의 배열과 상속 관계가 성립되어 굳이 타입 경계를 쓰지 않고 슈퍼타입으로 선언해주어도 서브타입이 들어올 수 있지만(`공변성`), 리스트 타입의 경우는 상속 관계가 성립되지 않으므로 타입 경계를 통해서 해결한다.

`자바의 모든 제네릭 타입은 불공변한다!!!`

## 서브타입 와일드카드
> 와일드카드를 사용한 리스트에서 데이터를 읽어올 수는 있지만 저장할 수는 없다.  
그 이유는 읽어온 객체는 와읻드카드를 통해 설정된 타입으로는 변환이 가능하므로 읽어오는데 아무 문제가 없다.  
또한 와일드카드를 통해 설정된 타입으로 변환이 가능하므로 어떠한 객체도 타입을 전부 충족시킬수 없으므로 저장할 수 없다.

## 슈퍼타입 와일드카드
> 예를 들어 Predicate인터페이스는 제네릭 타입과 마찬가지로 불변이지만 슈퍼타입 와일드카드를 통해 반공변하게 할수 있다.

## 선언처 공변성(declaration-site variance)과 사용처 공변성(use-site variance)
> 어떠한 메소드의 타입 파라미터를 반공변으로 선언하면 인자의 파라미터에 와일드카드를 사용할 필요가 없어진다. 이런 선언처 공변성은 편리하긴 하지만 자바 와일드카드의 사용처 공변성보다 강력하지는 않다.
`????????????????????????????`

## 와일드카드 사용되는 경우
> 예를 들어 리스트안에 null요소가 있는지 검사하는 메소드가 있다고 하자. 이 리스트안에는 어떤 파라미터가 오던지 메소드의 역할은 null값이 있는지만 확인하면 된다. 이처럼 값이 중요한게 아니라 그 내용이 중요한 경우에 와일드카드가 사용된다.

## 와일드카드 캡처
> 와일드카드(?)는 타입 인자로는 사용이 가능하지만 타입으로는 사용할 수 없다. 
```
public static void A (ArrayList<?> elements, int i, int j) {
    ? temp = elements.get(i);   // 동작x
    ...
}
```
> 이같은 상황을 해결하기 위해 제네릭 메소드를 호출해서 사용한다. 
```
private static <T> void B (ArrayList<T> elements, int i, int j) {
    T temp = elements.get(i);
    ...
}
  
public static void A (ArrayList<?> elements, int i, int j) {
    B (elements, i, j);
}
```
> 컴파일러는 ?가 무엇인지 모르지만 어떠한 타입을 나타내는건 알고있으므로 제네릭 메소드 호출이 가능하다. 이걸 와일드카드 캡처라고 한다.

`와일드카드 캡쳐의 이점 -> API사용자가 제네릭 메소드 대신 이해하기 쉬운 ArrayList<?>을 볼수 있다는점??`

## 제네릭의 제약
### 1. 기본 타입 인자가 없다.
> 제네릭은 기본타입 인자가 올수 없다.
### 2. 실행 시간에는 모든 타입이 raw타입이다.
> 가상 머신에는 오직 raw타입만 있다. 따라서 실행 시간에는 어떠한 타입객체를 담고 있는지 알수 없다.
### 3. 타입 변수의 인스턴스를 만들 수 없다.
> 제네릭 타입변수의 인스턴스(객체, 배열등)를 만들 수 없다. 따라서 이를 해결하기 위해서는 호출하는 쪽에서 생성자를 메소드 참조로 제공하게 해야한다. 이러한 이유로 굳이 배열을 만들어야 하는 경우가 아니라면 리스트를 사용하는게 좋다.
### 4. 파라미터화된 타입의 배열을 생성할 수 없다.
> 컴파일과정에서 타입을 지우고 rwa타입의 배열이 생성되기 떄문에 모든 타입의 객체가 생성될수 있으므로 오류가 발생한다. 이 또한 리스트를 사용하여 해결하는게 좋다.
### 5. 정적 컨텍스트에서는 클래스 타입 변수가 유효하지 않다.
> 정적 변수나 메소드에서는 타입 변수를 사용할 수 없다. p444???
### 6. 메서드가 소거 후 충돌하지 않을 수도 있다.

## 제네릭 예외처리
> 제네릭 클래스의 객체는 예외로 던지거나 잡아낼 수 없다. Throwable의 서브타입이 될수가 없다.  
그러나 throws선어에서 타입 변수로 제네릭을 사용하는건 가능하다.

## 제네릭을 사용한 예외처리의 장점
> 검사 예외와 비검사 예외 사이의 구분을 없앨 수 있다.

