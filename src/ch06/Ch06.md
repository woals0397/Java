## 제네릭 타입 파라미터가 기본 타입이 안되는 이유
> JDK1.5이전에는 제네릭이란 개념이 없었기때문에 이전 코드와의 호환성을 위해 제네릭은 컴파일 과정에서 타입 파라미터는 모두 Object로 변환되어 실행된다.  
즉, 제네릭이란 개념은 존재하지 않는다. 코드작성상에서만 존재하는 개념일뿐 컴파일 과정에서는 존재하지 않는 개념이다.  
기본 타입의 경우는 Object의 서브클래스가 아니므로 사용할 수 없다.

## 타입 경계
> 타입 경계를 통해 특정 타입 파라미터만 받게 할 수 있다.  
extends를 사용하여 특정 타입만 받을 수 있고, 특정 인터페이스를 구현한 클래스만 받고 싶을 경우에도   
`T extends 인터페이스명`으로 받을수 있다.  
다중으로 경계도 지정이 가능하다. 단, 클래스 경계는 하나만 지정할 수 있고, 인터페이스 경계는 제한이 없다.

## 배열은 타입 경계가 필요하지 않은 이유(공변성)
> 배열은 서브타입의 배열과 상속 관계가 성립되어 굳이 타입 경계를 쓰지 않고 슈퍼타입으로 선언해주어도 서브타입이 들어올 수 있지만(`공변성`), 리스트 타입의 경우는 상속 관계가 성립되지 않으므로 타입 경계를 통해서 해결한다.

`자바의 모든 제네릭 타입은 불공변한다!!!`

## 서브타입 와일드카드
> 와일드카드를 사용한 리스트에서 데이터를 읽어올 수는 있지만 저장할 수는 없다.  
그 이유는 읽어온 객체는 와읻드카드를 통해 설정된 타입으로는 변환이 가능하므로 읽어오는데 아무 문제가 없다.  
또한 와일드카드를 통해 설정된 타입으로 변환이 가능하므로 어떠한 객체도 타입을 전부 충족시킬수 없으므로 저장할 수 없다.

## 슈퍼타입 와일드카드
> 함수의 파라미터 타입은 반공변한다.

## 제네릭의 제약
`1 기본 타입 인자가 없다.`  
`2 실행 시간에는 모든 타입이 raw타입이다.`  
`3 타입 변수의 인스턴스를 만들 수 없다.`  
`4 파라미터화된 타입의 배열을 생성할 수 없다.`  
`5 정적 컨텍스트에서는 클래스 타입 변수가 유효하지 않다.`  
`6 메서드가 소거 후 충돌하지 않을 수도 있다.`