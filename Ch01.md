## Java의 장점
> 자바의 장점은 간결한 코드, 일관성, 뛰어난 이식성으로 클래스와 패키지로 구조화했을 때 이점을 얻는 대규모 프로그램 개발에 주로 사용된다.

## Java프로그램 실행 단계
> javac명령 : 자바소스코드 -> 바이트 코드로 컴파일  
java명령 : 가상머신 구동하여 컴파일된 파일 실행

## JRE / JDK
> JRE (Java Runtime Enviroment) : 컴파일된 자바 프로그램을 실행시킬 수 있는 자바환경, 자바 프로그램 실행시 반드시 필요하다.  
JDK (Java Development Kit) : 자바개발도구로써 자바 프로그래밍을 할 때 필요한 컴파일러 뿐만 아니라 JRE도 포함돼있다.

## Main문
> 프로그램이 실행될 때 첫번째로 호출되는 메소드로써 특정 객체를 대상으로 동작하지 않게 하기 위해 static으로 선언한다.

## 데이터타입
> 정수타입 : byte(1바이트) < short(2바이트) < int(4바이트) < long(8바이트)  
부동소수점 타입 : float(4바이트) < double(8바이트)  
char 타입 : 'a'~'z'  97~122 / 'A'~'Z'  65~90 / '0'~'9'  48~57  
boolean타입 : true, false값을 가지며, 0과1과 같은 숫자타입이 아니다.

`byte타입은 값 범위가 -128~127인데 0~255범위를 사용하고자 하면 그냥 byte에 넣으면 된다 . 그러나 이렇게해서 사용하면 덧셈과 뺄셈만 동작하고 다른 연산은 제대로 동작x(?) 제대로 동작하기 위해서 Byte.toUnsignedInt(값)을 이용해야한다.`

`정수는 0으로 나누면 ArithmeticException발생, 그러나 부동소수점은 0으로 나누면 무한대나 NaN이 나온다(?)`

## 논리연산자
> &&(논리곱)과 ||(논리합)의 경우 주어진 조건식중 하나의 결과에 의해 논리값이 정해지면 그 뒤에 조건식은 평가,실행되지 않는다. 

## 삼항연산자
```
조건식 ? 참일때 값 : 거짓일때 값;
```

`자바는 객체에 연산자를 사용할 수 없으므로 연산하기 위해서는 반드시 메소드를 호출해야 한다.`

`toString 과 +""방식 차이"`

## String클래스
> String클래스는 어떤 String메소드에도 값은 변하지 않는다.

## equals // ==
> equals는 객체타입을 비교할때 사용한다. 모든 객체들은 Objcet객체를 상속받는다.  
그러나, 기본타입들은 Object객체를 상속받지 않으므로 ==를 통해 비교한다.

```
equals의 null값 비교는 (null값이 아닌 객체).equals(null)의 형식으로 해주어야 NullPointerException오류가 발생하지 않는다.
@NotNull을 통해 null값을 인자로 전달받지 않게 하는것도 가능하다.
```

## 유니코드
> 유니코드가 나오기 이전에는 나라마다 다른 문자 인코딩 방식을 사용하여 서로 파일 교환에 문제가 발생하여 이를 해결하고자 유니코드 표준이 개발됐다.

## 코드 포인트
> 유효한 각각의 유니코드 값

`console클래스 : 비밀번호 설정시 사용 Scanner와의 차이?`

## 배열의 기본값
> (char를 포함한)숫자 타입의 배열 초기값 : 0  
boolean 타입의 배열 초기값 : false  
객체의 배열 초기값 : null

## 배열과 리스트
> 배열은 한번 생성하면 절대로 길이를 변경할 수 없지만 리스트는 객체 내부에서 배열을 관리한다.

## 기본 타입의 래퍼 클래스
> 리스트에서 기본 타입과 그에 대응하는 래퍼 타입 사이의 변환은 add, get등의 메소드호출에 의해 자동으로 일어난다.

## 가변 인자
```
public static double average(double... values)
```
> 인자의 개수를 정하지 않고 사용할 수 있게 메소드 정의가 가능하다.  
위의 코드처럼 타입 뒤에 ...을 붙이면 '가변 인자' 파라미터로 인식된다. 구현부에서는 배열처럼 사용을 하면 되고 가변 인자는 반드시 메소드의 마지막 파라미터여야 한다.

`SuppressWarnings?`