## Java의 장점
> 자바의 장점은 간결한 코드, 일관성, 뛰어난 이식성으로 클래스와 패키지로 구조화했을 때 이점을 얻는 대규모 프로그램 개발에 주로 사용된다.

## Java프로그램 실행 단계
> javac명령 : 자바소스코드 -> 바이트 코드로 컴파일  
java명령 : 가상머신 구동하여 컴파일된 파일 실행

## Main문
> 프로그램이 실행될 때 첫번째로 호출되는 메소드로써 특정 객체를 대상으로 동작하지 않게 하기 위해 static으로 선언한다.

## 데이터타입
> 정수타입 : byte(1바이트) < short(2바이트) < int(4바이트) < long(8바이트)  
부동소수점 타입 : float(4바이트) < double(8바이트)  
char 타입 : 'a'~'z'  97~122 / 'A'~'Z'  65~90 / '0'~'9'  48~57  
boolean타입 : true, false값을 가지며, 0과1과 같은 숫자타입이 아니다.

`byte타입은 값 범위가 -128~127인데 0~255범위를 사용하고자 하면 그냥 byte에 넣으면 된다 . 그러나 이렇게해서 사용하면 덧셈과 뺄셈만 동작하고 다른 연산은 제대로 동작x(?) 제대로 동작하기 위해서 Byte.toUnsignedInt(값)을 이용해야한다.`

`정수는 0으로 나누면 ArithmeticException발생, 그러나 부동소수점은 0으로 나누면 무한대나 NaN이 나온다(?)`

## 논리연산자
> &&(논리곱)과 ||(논리합)의 경우 주어진 조건식중 하나의 결과에 의해 논리값이 정해지면 그 뒤에 조건식은 평가,실행되지 않는다. 

## 삼항연산자
```
조건식 ? 참일때 값 : 거짓일때 값;
```

`자바는 객체에 연산자를 사용할 수 없으므로 연산하기 위해서는 반드시 메소드를 호출해야 한다.`
## 





큰 숫자
BigInteger, BigDecimal클래스를 이용한다. 자바는 객체에 연산자 사용이 불가능하므로, 연산을 하기위해서는 메서드 호출을 해야한다.

문자열
문자열간 비교는 equals메서드를 사용해야 하며, null값인지를 확인하기 위해서는 ==연산자를 사용해야 한다. 또한, null값과 빈 문자열("")은 다르다는 점을 유의해야 한다. equalsIgnoreCase => 대소문자 구별없이 문자열 비교 메서드 compareTo => 두 문자열의 오름차순 순서를 알려주는 메서드

지역변수의 유효 범위
지역변수는 메서드 안에 선언한 변수이다. 유효 범위는 변수 선언지점부터 해당 선언을 감싸는 블록 끝까지이다. 유효 범위가 겹치지 않을 경우, 같은 변수명도 재사용이 가능하다.

길이가 0인 배열
배열에 저장된 값이 1개도 없는 배열을 의미하며, null과는 다르다.

ArrayList
ArrayList는 클래스로 정의되어있어 인스턴스 생성과 메서드 호출을 통해 사용한다. 배열의 경우 선언할때 크기가 정해지면 도중에 바꾸는게 불가능하지만 ArrayList는 객체 내부에서 배열을 관리한다.

ArrayList A = new ArrayList<>(); // 선언 A.add("ABC"); // 요소 추가 A.remove(1); // 요소 삭제 A.get(0); // 요소 읽어오기 A.set(1, "DEF"); // 요소값 교체 A.size() // 리스트의 크기 반환

래퍼 클래스
ArrayList와 같은 제네릭 클래스는 기본 타입을 타입 파라미터로 사용할 수 없다는 단점이 있다. 예를 들어, ArrayList는 사용할 수 없는 구문이다. 따라서, 정수를 처리하기 위해서 ArrayList를 사용해야 한다.

배열 알고리즘
Arrays => 배열 Collections => 배열리스트 fill 요소 채우는 메소드 sort 정렬 메소드 toString 배열 String형식으로 출력 --> 그냥 println만 해줘도 알아서 내부에서 처리해준다.

배열리스트에만 있는 메서드
reverse 요소들을 뒤집는 메소드 shuffle 요소들을 임의로 섞는 메소드

#명령줄 인자

JDK / JRE의 차이

삼항연산자

static관련 메모리 구조

equals // ==
equals는 객체타입비교 => 모든객체들은 Object객체를 상속받는다
그러나, 기본타입들은 Object객체를 상속받지 않음
equals의 null값비교 
null.equals(a);
a..equals(null);

List<Integer> a = 
List로 선언해줘야 나중에 수정하기 좋다


